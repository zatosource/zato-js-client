<!doctype html>
<html>
<head>

<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

  <script type="text/javascript">

/* **************************************************************************************************************************** */

/*
   A Zato WebSocket client which knows how to:

   * Establish long-running connections
   * Invoke services
   * Subscribe to pub/sub messages
   * Unsubscribe from pub/sub
   * Resume subscriptions
*/
class WSXClient {

/* **************************************************************************************************************************** */

  constructor() {

    // Client ID -> a random string
    this.client_id = null;

    // Client name -> human-readable
    this.client_name = null;

    // WSX address to connect to
    this.address = null;

    // Username to log in with
    this.username = null;

    // Password to log in with
    this.password = null;

    // Zato WSX token that we will be using once logged in
    this.invalid_token = '<invalid>';
    this.token = this.invalid_token;

    // The underlying WebSocket object
    this.impl = null;

    // A dictionary of msg_id objects to which we expect a response
    this.response_map = {};

    // How many milliseconds to wait for a response from Zato by default
    this.default_wait_time = 500;

    // A callback to invoke after the connection is established
    this.when_ready = null;

    // A callback to invoke after each message from Zato received
    this.on_message_received = null;

    // Are we already connected to Zato?
    this._is_connected = false;
  }

/* **************************************************************************************************************************** */

  connect() {
    console.log('Connecting to '+ this.address);

    // Establish a new connection
    this.impl = new WebSocket(this.address);

    // Assign a callback that will obtain a session token
    this.impl.onopen = this.on_wsx_open.bind(this);

    // A callback invoked for each message received from the server
    this.impl.onmessage = this.on_wsx_message.bind(this);
  }

/* **************************************************************************************************************************** */

  on_wsx_open(e) {
    console.log(`>> Connected to '${this.address}'`)

    // Set a flag signalling that we are connected now
    this._is_connected = true;

    // Request a session token now that we have connected
    const msg_id = this.generate_msg_id();
    const msg = this.get_create_session_message(msg_id);

    // A callback to invoke after we have a session established with Zato
    function on_session_created() {
      const msg = this.response_map[msg_id];
      console.log(`>> Received session token '${msg.data.token}' for client '${this.client_name}' (${this.client_id})`);
      this.token = msg.data.token;
      this.when_ready(this);
    }

    // Request a session token ..
    this.send(msg_id, msg);

    // .. and wait for it.
    this._wait_for_response(msg_id, on_session_created);
  }

/* **************************************************************************************************************************** */

  _check_is_connected() {
    return this._is_connected;
  }

/* **************************************************************************************************************************** */

  _check_has_token() {
    return this.token != this.invalid_token;
  }

/* **************************************************************************************************************************** */

  _check_has_response(msg_id) {
    return this.response_map[msg_id];
  }

/* **************************************************************************************************************************** */

  _continue_to_wait(attempts, condition_func, callback_func, object_type) {
    console.log(`<< Waiting for '${object_type}' to '${this.address}', attempts left: ${attempts+1}`);
    setTimeout(this.wait_for_event.bind(this), 1000, attempts, condition_func, callback_func, object_type);
  }

/* **************************************************************************************************************************** */

  wait_for_event(attempts, condition_func, callback_func, object_type) {
    if(!condition_func()) {
      if(attempts < 0) {
        console.log(`Could not obtain ${object_type} to ${this.address}`);
      }
      else {
        this._continue_to_wait(attempts-1, condition_func, callback_func, object_type);
      }
    }
    else {
      if(callback_func) {
        callback_func.bind(this)();
      }
    }
  }

/* **************************************************************************************************************************** */

  wait_until_ready(attempts) {
    this.wait_for_event(attempts, this._check_is_connected.bind(this), null, 'connection');
  }


/* **************************************************************************************************************************** */

  _wait_for_token() {
    this.wait_for_event(1000, this._check_has_token.bind(this), this.when_ready, 'token');
  }

/* **************************************************************************************************************************** */

  _wait_for_response(msg_id, callback_func) {
    this.wait_for_event(100, this._check_has_response.bind(this, msg_id), callback_func, 'response');
  }

/* **************************************************************************************************************************** */

  get_base_message(msg_id) {
    let msg = {}
    msg.meta = {
        'id': msg_id,
        'timestamp': new Date().toISOString(),
    }
    return msg;
  }

/* **************************************************************************************************************************** */

  get_create_session_message(msg_id) {

    // Base message to enrich with additional information
    let msg = this.get_base_message(msg_id);

    msg.meta.action = 'create-session';

    msg.meta.client_id = this.client_id;
    msg.meta.client_name = this.client_name;

    msg.meta.username = this.username;
    msg.meta.password = this.password;

    return JSON.stringify(msg);
  }

/* **************************************************************************************************************************** */

  get_service_invoke_message(msg_id, service, request) {

    // Base message to enrich with additional information
    let msg = this.get_base_message(msg_id);

    msg.meta.action = 'invoke-service';
    msg.meta.token = this.token;
    msg.meta.id = msg_id;

    msg.data = {
      'service': service,
      'request': request
    }

    return JSON.stringify(msg);
  }

/* **************************************************************************************************************************** */

  generate_msg_id() {
    return this.client_name + '.' + Math.random().toString(16);
  }

/* **************************************************************************************************************************** */

  send(msg_id, msg) {

    // Add msg_id to the response map, signalling thus that we expect a response
    this.response_map[msg_id] = null;

    // Invoke Zato
    this.impl.send(msg);
  }

/* **************************************************************************************************************************** */

  handle_response(msg_id) {
    const response = this.response_map[msg_id];
    console.log(`>> Response to '${msg_id}' is ${JSON.stringify(response)}`);

    this.on_message_received(this, response);
  }

/* **************************************************************************************************************************** */

  invoke(service, request, _msg_id) {
    const msg_id = _msg_id || this.generate_msg_id();
    const msg = this.get_service_invoke_message(msg_id, service, request);
    console.log(`<< Invoking service with ${msg}`);

    function _handle_response() {
      return this.handle_response.bind(this)(msg_id);
    }

    this.send(msg_id, msg);
    this._wait_for_response(msg_id, _handle_response);
  }

/* **************************************************************************************************************************** */

  on_wsx_message(e) {

    // Log data received
    console.log(`>> Message received ${e.data}`);

    // We always expect JSON on input
    const msg = JSON.parse(e.data);

    /* If this is a response, store it for the original caller to be able to find it.
       Otherwise, invoke a callback function to
    */
    if(msg.meta.in_reply_to) {
      this.response_map[msg.meta.in_reply_to] = msg;
    }
    else {
      zzz
    }
  }
};

/* **************************************************************************************************************************** */

const client_id   = '123.456.789';
const client_name = 'My API Client';
const address     = 'ws://localhost:50100/myapi'
const username    = 'username1';
const password    = 'password1';

/* **************************************************************************************************************************** */

// A callback function to be invoked for each message received from Zato
function on_message_received(client, msg) {
  console.log(`>> Callback invoked with ${msg}`);
}

/* **************************************************************************************************************************** */

// A callback function to be invoked once the client connects to Zato
function when_ready(client) {
  console.log(`>> Client ${client.client_name} connected to ${client.address} as ${client.username}`);

  // Service invocation configuration
  const service = 'zato.ping';
  const request = {'Hello':'World'};

  // Pub/sub configuration
  const topic_name = '/my/topic';

  client.invoke(service, request);
}

/* **************************************************************************************************************************** */

// Create a client instance
let client = new WSXClient();

// Fill out configuration
client.client_id = client_id;
client.client_name = client_name;
client.address = address;
client.username = username;
client.password = password;

client.when_ready = when_ready;
client.on_message_received = on_message_received;

/* **************************************************************************************************************************** */

// Connect to Zato
client.connect();

/* **************************************************************************************************************************** */

// Connection will established in background so we need to wait for it
client.wait_until_ready(60)

/* **************************************************************************************************************************** */

  </script>
</head>
<body>
</body>
